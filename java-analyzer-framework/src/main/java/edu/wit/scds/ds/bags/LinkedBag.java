/* @formatter:off * * Â© David M Rosenberg * * Topic: Bags * * Usage restrictions: * * You may use this code for exploration, experimentation, and furthering your * learning for this course. You may not use this code for any other * assignments, in my course or elsewhere, without explicit permission, in * advance, from myself (and the instructor of any other course). * * Further, you may not post (including in a public repository such as on github) * nor otherwise share this code with anyone other than current students in my * sections of this course. * * Violation of these usage restrictions will be considered a violation of * Wentworth Institute of Technology's Academic Honesty Policy.  Unauthorized posting * or use of this code may also be considered copyright infringement and may subject * the poster and/or the owners/operators of said websites to legal and/or financial * penalties.  Students are permitted to store this code in a private repository * or other private cloud-based storage. * * Do not modify or remove this notice. * * @formatter:on *//* @formatter:off * * You must: *  - replace "Your Name" with your actual name in the class Javadoc comment block *  - once you complete each task, delete the entire "// TODO..." comment *  - follow my coding style *      - use my configuration settings (see Resources in Brightspace) *          - use my provided code as a guide/template - maintain this style *      - see Appendix A in the textbook for the basics *      - qualify all instance variable references with 'this.' *          - for example, this.numberOfEntries rather than numberOfEntries *          - I don't typically qualify instance method invocations with 'this.' *              - exception: I'm manipulating two or more instances in a method *      - braces are required for single-line statements *          - for example: *              if ( condition ) *                  { *                  do something ; *                  } *          - use next-line, indented brace position (as above) *      - fully spell out your variable, parameter, method, class names * * You may not use any Java Class Library (JCL) classes or methods other than: *      StringBuilder - in toString() to construct the output String *          - you may construct and use Strings for output but you aren't *              permitted to use any String methods *      Arrays - you need to instantiate and manipulate arrays in toArray() and *               add(T[]) but you aren't permitted to use any Array/Arrays methods *      print(), etc. - for debugging only * * You should: *  - find the appropriate code in the textbook or in the code I provided for *      lectures (links in the Weekly Plans) and copy it (do not attribute) *  - the array constructor, cloning constructor, difference(), intersection(), *      union(), initializeState(), and add(T[]) are not in the book - they are *      described in the assignment and the Javadoc comments * * @formatter:on */package edu.wit.scds.ds.bags ;import edu.wit.scds.ds.common.chains.enhanced.Node ;import java.util.Arrays ;/** * A class of bags whose entries are stored in a chain of linked nodes. The bag * is never full. * <p> * Note: This implementation does not permit {@code null} entries. * * @author Frank M. Carrano * @author Timothy M. Henry * * @version 4.1 * * @author David M Rosenberg * * @version 4.2 2016-01-10 Reformat and revise * @version 4.3 2019-05-12 Add 'cloning' constructor, {@code difference()}, *     {@code intersection()}, {@code union()} * @version 4.4 2019-05-24 standardize on {@code resultBag} for returned *     construct variable name for {@code difference()}, {@code intersection()}, *     {@code union()} * @version 4.5 2020-01-28 *     <ul> *     <li>add constructor taking array of entries *     <li>move {@code Node} to a separate class *     </ul> * @version 4.6 2020-05-16 add check for null argument to difference() * @version 4.7 2020-08-08 track changes to BagInterface - now extend *     EnhancedBagInterface instead * @version 4.8 2020-09-13 *     <ul> *     <li>track changes to BagInterface.java - switch back to it *     <li>copy all Javadoc comments from BagInterface.java to here instead of *     referencing them *     <li>restructured some methods to return as soon as possible *     </ul> * @version 4.9 2022-10-11 full solution * @version 4.10 2023-10-19 *     <ul> *     <li>remove Javadoc comment blocks for methods declared (and documented) *     in {@code BagInterface} since they're redundant *     <li>add implementations for some methods *     </ul> * @version 4.11 2024-02-13 implementation per assignment * @version 4.12 2024-10-19 *     <ul> *     <li>add implementations per assignment of {@code areDisjointSets()}, *     {@code isProperSubsetOf()}, and {@code isSubsetOf()} *     <li>revise {@code toString()} to include {@code this.numberOfEntries} as *     a debugging aid *     <ul> * @version 5.0 2025-01-28 track changes to switch back to use 'bag' instead of *     'list' or 'unordered list' * @version 6.0 2025-02-12 remove all set-type methods * @version 6.1 2025-06-08 make class final * * @param <T> *     The class of entry the {@code LinkedBag} will hold. */public final class LinkedBag<T> implements BagInterface<T>    {    /*     * data fields/instance variables     */    private Node<T> firstNode ;     // reference to first node    private int numberOfEntries ;   // count of entries in use    /*     * constructors     */    /**     * Initialize a new, empty LinkedBag     */    public LinkedBag()        {        // initialize the bag - state is empty        initializeState() ;        // Do not make any changes to this constructor - initializeState() will        // do        // the setup        }    // end no-arg constructor    /**     * 'Cloning' constructor - initialize a new {@code LinkedBag} and populate     * it with the contents of {@code sourceBag}     *     * @param sourceBag     *     another bag containing zero or more entries to copy to the newly     *     instantiated {@code LinkedBag} - if {@code null}, the new     *     {@code LinkedBag} will be empty     *     <p>     *     Note: {@code sourceBag} is an instance of any class that implements     *     {@code BagInterface} - it doesn't have to be another     *     {@code LinkedBag}     *     <p>     *     Post-condition: the contents of {@code sourceBag} are unchanged.     */    public LinkedBag( final BagInterface<T> sourceBag )        {        this() ;    // known valid starting state: empty        if ( sourceBag instanceof final LinkedBag<T> sourceLinkedBag )            {            // sourceBag is a LinkedBag - we can directly access its contents            // traverse its chain to add its contents to 'us'            Node<T> currentNode = sourceLinkedBag.firstNode ;            while ( currentNode != null )                {                // add the entry                this.add( currentNode.getData() ) ;                // move to the next node                currentNode = currentNode.getNext() ;                }            }        else if ( sourceBag != null )   // sourceBag exists and is not a                                        // LinkedBag            {            // since we can't access its state/instance variables, fall-back to            // adding its contents via an array of its entries            this.add( sourceBag.toArray() ) ;            }        }    // end 1-arg 'cloning' constructor    /**     * Initialize a new {@code LinkedBag} and populate it with the contents of     * {@code initialContents}- if {@code null}, the new {@code LinkedBag} will     * be empty     *     * @param initialContents     *     an array of zero or more entries to copy to the newly instantiated     *     {@code LinkedBag}     *     <p>     *     Post-condition: the contents of {@code initialContents} are     *     unchanged.     */    public LinkedBag( final T[] initialContents )        {        this() ;    // known valid starting state: empty        // treat a null parameter as if it's an empty array - ignore it        // Note: if initialContents contains any nulls, add() will throw an        // IllegalArgumentException        if ( initialContents != null )  // initialContents exists            {            this.add( initialContents ) ;            }        }    // end 1-arg 'array' constructor    /*     * API methods     */    @Override    public boolean add( final T newEntry )        {        // prevent null entries        if ( newEntry == null )            {            throw new IllegalArgumentException( "entry cannot be null" ) ;            }        // create a new Node for this entry pointing it at the current first        // entry (Node) in the chain - will be null if the bag is empty        final Node<T> newNode = new Node<>( newEntry, this.firstNode ) ;        // make it the first entry in the chain        this.firstNode = newNode ;        // count this entry        this.numberOfEntries++ ;        // always succeeds        return true ;        }    // end add()    @Override    public void clear()        {        // re-initialize the state to empty        initializeState() ;        // Do not make any changes to this method - initializeState() will reset        // the        // state to empty with O(1) efficiency.        }    // end clear()    @Override    public boolean contains( final T anEntry )        {        // get a reference to the first matching entry - eliminates duplicate        // code        return getReferenceTo( anEntry ) != null ;        }    // end contains()    @Override    public BagInterface<T> difference( final BagInterface<T> anotherBag )        {        // clone ourself - we'll return the clone bag        final BagInterface<T> resultBag = new LinkedBag<>( this ) ;        // remove any entry from resultBag that's in anotherBag        // if anotherBag is a LinkedBag we can directly traverse its entries        if ( anotherBag instanceof final LinkedBag<T> anotherLinkedBag )            {            // look at each entry in anotherBag by traversing its chain            Node<T> currentNode = anotherLinkedBag.firstNode ;            // unconditionally try to remove each entry in anotherBag from            // resultBag            while ( currentNode != null )                {                // try to remove the entry - ignore success/failure status                resultBag.remove( currentNode.getData() ) ;                // move to the next node                currentNode = currentNode.getNext() ;                }            }        else if ( anotherBag != null )  // anotherBag exists and is not a                                        // LinkedBag            {            // since we can't access its state/instance variables, fall-back to            // interrogating its contents via an array of its entries            for ( final T anotherBagContent : anotherBag.toArray() )                {                // try to remove the entry - ignore success/failure status                resultBag.remove( anotherBagContent ) ;                }            }        return resultBag ;        }   // end difference()    @Override    public int getCurrentSize()        {        // simply return the number of entries        return this.numberOfEntries ;        }    // end getCurrentSize()    @Override    public int getFrequencyOf( final T anEntry )        {        // null can't be present in the bag so simply indicate we didn't find it        if ( anEntry == null )            {            return 0 ;            }        int foundCount = 0 ;     // number of matching elements        // traverse the chain        Node<T> currentNode = this.firstNode ;        while ( currentNode != null )            {            // check for a match            if ( currentNode.getData().equals( anEntry ) )                {                // we have a match                foundCount++ ;                }            // move to the next node            currentNode = currentNode.getNext() ;            }   // end while        return foundCount ;        }    // end getFrequencyOf()    @Override    public BagInterface<T> intersection( final BagInterface<T> anotherBag )        {        // create an empty bag - we'll populate it with entries that appear in        // both our (this) bag and anotherBag        final BagInterface<T> resultBag = new LinkedBag<>() ;        // we'll clone anotherBag        final BagInterface<T> clonedAnotherBag = new LinkedBag<>( anotherBag ) ;        // then traverse our chain        Node<T> currentNode = this.firstNode ;        while ( currentNode != null )            {            final T currentData = currentNode.getData() ; // for convenience            // if we find the current entry from our chain in the cloned bag,            // remove it from the cloned bag and add it to the intersection bag            // Note: remove( currentData ) does double duty since it returns the            // same            // result as contains() would return            if ( clonedAnotherBag.remove( currentData ) )                {                // both bags contain this entry so add it to the result                resultBag.add( currentData ) ;                }            // move to the next node            currentNode = currentNode.getNext() ;            }   // end while        return resultBag ;        }   // end intersection()    @Override    public boolean isEmpty()        {        // simply check the current number of entries        return this.numberOfEntries == 0 ;        }    // end isEmpty()    @Override    public T remove()        {        // if the bag is empty, indicate that by returning null        if ( isEmpty() )            {            return null ;   // nothing to remove            }        // assertion: the bag isn't empty        // grab the data from the first Node in the chain        final T anEntry = this.firstNode.getData() ;        // drop the first node from the chain        this.firstNode = this.firstNode.getNext() ;        // decrement the number of entries        this.numberOfEntries-- ;        return anEntry ;        }    // end no-arg remove()    @Override    public boolean remove( final T anEntry )        {        // get a reference to a node that matches the parameter        // getReferenceTo() treats null as unfindable so returns null        final Node<T> foundEntry = this.getReferenceTo( anEntry ) ;        // if we didn't find a match, we're done        if ( foundEntry == null )            {            return false ;      // indicate no match            }        // assertion: the chain can't be empty so there is a first node        // replace the found entry's node's data with the data from the        // first node        foundEntry.setData( this.firstNode.getData() ) ;        // drop the first node from the chain        // assertion: unspecified remove() removes the first node        remove() ;        // let the caller know we were able to remove the requested entry        return true ;        }    // end 1-arg remove()    @Override    public T[] toArray()        {        // instantiate an array to contain the entries        @SuppressWarnings( "unchecked" )        final T[] result = (T[]) new Object[ this.numberOfEntries ] ;        // traverse the chain copying data references into sequential elements        // of the array        int index = 0 ;        Node<T> currentNode = this.firstNode ;        while ( currentNode != null )            {            result[ index ] = currentNode.getData() ;            currentNode = currentNode.getNext() ;            index++ ;            } // end while        return result ;        }    // end toArray()    @Override    public String toString()        {        // Note: we don't typically implement toString() in a collection - this        // one is        // provided as a debugging aid        /*         * we'll return a string of comma-separated text representations of each         * entry and surround them with square brackets         */        return String.format( "nOE: %,d; data: %s",                              this.numberOfEntries,                              Arrays.toString( toArray() ) ) ;        }   // end toString()    @Override    public BagInterface<T> union( final BagInterface<T> anotherBag )        {        // clone the other bag        // - we'll return the cloned bag        // - cloning constructor properly handles the case of null parameter        // (treats        // it as if empty)        final BagInterface<T> resultBag = new LinkedBag<>( anotherBag ) ;        // add each entry from this bag to resultBag        Node<T> currentNode = this.firstNode ;        while ( currentNode != null )            {            // add the entry - ignore success/failure status            resultBag.add( currentNode.getData() ) ;            // move to the next node            currentNode = currentNode.getNext() ;            }        return resultBag ;        }   // end union()    // end of LinkedBag API methods    /*     * private utility methods     */    /**     * Utility method to load this bag with the provided items     *     * @param newEntries     *     the items to add     *     <ul>     *     <li>array will never be {@code null}     *     <li>{@code add( entry )} will prevent adding {@code null} entries     *     </ul>     *     <p>     *     Pre-condition: newEntries is never {@code null}     *     <p>     *     Post-condition: the contents of {@code newEntries} are unchanged     */    private void add( final T[] newEntries )        {        // Note: if newEntries contains any nulls, add() will throw an        // IllegalArgumentException - do not check for null entries in this        // method        for ( final T anItem : newEntries )            {            add( anItem ) ;            }        }   // end add() from array    /**     * Find a node in the chain with data that matches the parameter.     *     * @param anEntry     *     the entry to match     *     * @return a reference to a node containing a matching entry or {@code null}     *     if not found     */    private Node<T> getReferenceTo( final T anEntry )        {        // null can't be present in the bag so simply indicate we didn't find it        if ( anEntry == null )            {            return null ;            }        // traverse the chain starting with the first node        Node<T> currentNode = this.firstNode ;        while ( currentNode != null )            {            if ( currentNode.getData().equals( anEntry ) )                {                // we found a match so stop looking                return currentNode ;                }   // end if            // didn't find it (yet) so move to the next node            currentNode = currentNode.getNext() ;            }   // end while        // return null to indicate no match        return null ;        }    // end getReferenceTo()    /**     * Initialize the state of the current {@code LinkedBag} to empty     */    private void initializeState()        {        // (re)set the state to empty        this.firstNode = null ;        this.numberOfEntries = 0 ;        }    // end initializeState()    /**     * (optional) test driver for LinkedBag     *     * @param args     *     -unused-     */    public static void main( final String[] args )        {        // OPTIONAL for debugging/testing        final BagInterface<String> bag1 = new LinkedBag<>() ;        printStuff( bag1, null ) ;        final BagInterface<String> bag2 = new ArrayBag<>() ;        printStuff( bag1, bag2 ) ;        bag1.add( "a" ) ;        printStuff( bag1, bag2 ) ;        bag2.add( "a" ) ;        printStuff( bag1, bag2 ) ;        bag2.add( "b" ) ;        printStuff( bag1, bag2 ) ;        bag1.add( "a" ) ;        bag2.add( "b" ) ;        printStuff( bag1, bag2 ) ;        bag2.add( "a" ) ;        printStuff( bag1, bag2 ) ;        bag1.add( "a" ) ;        printStuff( bag1, bag2 ) ;        bag2.clear() ;        bag2.add( "z" ) ;        bag2.add( "y" ) ;        bag2.add( "x" ) ;        bag2.add( "w" ) ;        printStuff( bag1, bag2 ) ;        }    // end main()    private static void printStuff( final BagInterface<String> bag1,                                    final BagInterface<String> bag2 )        {        System.out.printf( "linked and array-backed bags:%nLB: %s%nAB: %s%n%n", bag1, bag2 ) ;//        System.out.printf( "1l.aDS(l2): %b%n", bag1.areDisjointSets( bag2 ) ) ;//        System.out.printf( "l1.iSO(l2): %b%n", bag1.isSubsetOf( bag2 ) ) ;//        System.out.printf( "l1.iPSO(l2): %b%n%n----------%n%n", bag1.isProperSubsetOf( bag2 ) ) ;        }   // end printStuff()    }    // end class LinkedBag