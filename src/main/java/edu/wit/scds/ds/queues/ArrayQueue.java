/* @formatter:off * * Â© David M Rosenberg * * Topic: Queues, Deques, and Priority Queues * * Usage restrictions: * * You may use this code for exploration, experimentation, and furthering your * learning for this course. You may not use this code for any other * assignments, in my course or elsewhere, without explicit permission, in * advance, from myself (and the instructor of any other course). * * Further, you may not post (including in a public repository such as on github) * nor otherwise share this code with anyone other than current students in my * sections of this course. * * Violation of these usage restrictions will be considered a violation of * Wentworth Institute of Technology's Academic Honesty Policy.  Unauthorized posting * or use of this code may also be considered copyright infringement and may subject * the poster and/or the owners/operators of said websites to legal and/or financial * penalties.  My students are permitted to store this code in a private repository * or other private cloud-based storage. * * Do not modify or remove this notice. * * @formatter:on */package edu.wit.scds.ds.queues ;import java.util.Arrays ;import java.util.NoSuchElementException ;/** * A class that implements the ADT queue by using an expandable circular array. * * @author Frank M. Carrano * @author Timothy M. Henry * * @version 4.0 * @version 5.0<br/> * * @author David M Rosenberg * * @version 4.1 *     <ul> *     <li>initial version based upon Carrano and Henry implementation in the *     4th edition of the textbook *     <li>modified per assignment *     </ul> * @version 5.1 2019-07-14 *     <ul> *     <li>simplified determination of parameters to {@code System.arraycopy()} *     in {@code ensureCapacity()} *     <li>revisions to match: *     <ul> *     <li>the 5th edition of the textbook *     <li>Dave Rosenberg Company coding standard *     <li>this semester's assignment *     </ul> *     </ul> * @version 5.2 2019-10-23 revise for this semester<br/> * @version 5.3 2020-03-01 *     <ul> *     <li>update to coding standard *     <li>switch from {@code QueueInterface} to {@code TestableQueueInterface} *     </ul> * @version 5.4 2020-06-21 *     <ul> *     <li>rename {@code isFull()} to {@code isArrayFull()} to more accurately *     describe its functionality *     <li>remove code which prevented adding null *     </ul> * @version 5.5 2020-10-19 *     <ul> *     <li>switch back to {@code QueueInterface} instead of *     {@code TestableQueueInterface} *     <li>remove {@code size()} and {@code toArray()} *     <li>add {@code toString()} to aid debugging *     <li>implement {@code main()} to aid debugging *     </ul> * @version 5.6 2020-10-31 *     <ul> *     <li>add invocation of {@code checkIntegrity()} in {@code isEmpty()} *     <li>remove {@code oldQueue} and {@code oldSize} in *     {@code ensureCapacity()} *     <li>enhance {@code toString()} to display queue length *     <li>restructure {@code main()} and include {@code clear()} *     </ul> * @version 5.7 2024-03-12 minor enhancement to {@code toString()} to display *     {@code integrityOK} flag and better handle an instance with no *     {@code queue} array. * @version 6.0 2025-04-05 *     <ul> *     <li>reject {@code null} entries *     <li>provide full implementation of {@code checkCapacity()} *     </ul> * @version 7.0 2025-10-23 replace {@code EmptyQueueException} with *     {@code NoSuchElementException} * * @param <T> *     The type of all objects to store in the queue */public final class ArrayQueue<T> implements QueueInterface<T>    {    /*     * utility constants     */    /** default (and minimum) number of entries in a queue */    private static final int DEFAULT_CAPACITY = ArrayQueueCapacity.DEFAULT.capacityValue ;    /** maximum number of entries in a queue */    private static final int MAX_CAPACITY = ArrayQueueCapacity.MAXIMUM.capacityValue ;    /*     * data fields     */    /** circular array of queue entries */    private T[] queue ;    /** index of front entry */    private int frontIndex ;    /** index of back entry */    private int backIndex ;    /** number of entries currently in the queue */    private int numberOfEntries ;    /** indicate that object is in a valid, known state */    private boolean integrityOK = false ;    /*     * constructors     */    /**     * Initializes a queue with a default capacity     */    public ArrayQueue()        {        this( DEFAULT_CAPACITY ) ;        } // end no-arg constructor    /**     * Initializes a queue with a specified capacity     *     * @param initialCapacity     *     in the range DEFAULT_CAPACITY..MAX_CAPACITY     *     * @throws IllegalStateException     *     if the {@code desiredCapacity} is outside the valid range     */    public ArrayQueue( final int initialCapacity )        {        initializeState( initialCapacity ) ;        } // end 1-arg constructor    /*     * public API methods     */    @Override    public void clear()        {        initializeState( this.queue.length ) ; // reinitialize with current size        }   // end clear()    @Override    public T dequeue()        {        // save the front item        final T front = getFront() ;    // performs integrity and empty checks        // remove it from the array        this.queue[ this.frontIndex ] = null ;        this.frontIndex = ( this.frontIndex + 1 ) % this.queue.length ;        this.numberOfEntries-- ;        return front ;        }   // end dequeue()    @Override    public void enqueue( final T newEntry )        {        checkIntegrity() ;        // reject null entries        if ( newEntry == null )            {            throw new IllegalArgumentException( "null" ) ;            }        ensureCapacity() ;        this.backIndex = ( this.backIndex + 1 ) % this.queue.length ;        this.queue[ this.backIndex ] = newEntry ;        this.numberOfEntries++ ;        }   // end enqueue()    @Override    public T getFront()        {        checkIntegrity() ;        if ( isEmpty() )            {            throw new NoSuchElementException() ;            }        return this.queue[ this.frontIndex ] ;        }   // end getFront()    @Override    public boolean isEmpty()        {        checkIntegrity() ;        return this.numberOfEntries == 0 ;        }   // end isEmpty()    /*     * private utility methods     */    /**     * Validate that the desired capacity is within acceptable limits.     *     * @param desiredCapacity     *     size in the range DEFAULT_CAPACITY..MAX_CAPACITY, inclusive     *     * @throws IllegalStateException     *     if the {@code desiredCapacity} is outside the valid range     */    private static void checkCapacity( final int desiredCapacity )        {        if ( desiredCapacity < DEFAULT_CAPACITY )            {            throw new IllegalStateException( "Attempt to create a queue whose " + "capacity is too small ("                                             + desiredCapacity + ")." ) ;            }        if ( desiredCapacity > MAX_CAPACITY )            {            throw new IllegalStateException( "Attempt to create a queue whose " + "capacity is too large ("                                             + desiredCapacity + ")." ) ;            }        }   // end checkCapacity()    /**     * Ensure the instance is in a valid, usable state     */    private void checkIntegrity()        {        if ( !this.integrityOK )            {            throw new SecurityException( "ArrayQueue object is corrupt." ) ;            }        }   // end checkIntegrity()    /**     * Doubles the size of the array queue if it is full     * <p>     * Precondition: checkIntegrity() has been called.     */    private void ensureCapacity()        {        if ( isArrayFull() )    // if array is full, double size of array            {            final int newSize = 2 * this.numberOfEntries ;            checkCapacity( newSize ) ;            // The cast is safe because the new array contains null entries            @SuppressWarnings( "unchecked" )            final T[] tempQueue = (T[]) new Object[ newSize ] ;            // copy the front of the queue            System.arraycopy( this.queue,       // from                              this.frontIndex,                              tempQueue,        // to                              0,                              this.numberOfEntries - this.frontIndex ) ;            // how many elements            // copy the back of the queue            System.arraycopy( this.queue,       // from                              0,                              tempQueue,        // to                              this.numberOfEntries - this.frontIndex,                              this.frontIndex ) ;   // how many elements            this.integrityOK = false ;            // update the state to utilize the new queue array            this.queue = tempQueue ;            this.frontIndex = 0 ;            this.backIndex = this.numberOfEntries - 1 ;            this.integrityOK = true ;            } // end if        } // end ensureCapacity()    /**     * Initializes a queue with a specified capacity     *     * @param desiredCapacity     *     in the range DEFAULT_CAPACITY..MAX_CAPACITY, inclusive     */    private void initializeState( final int desiredCapacity )        {        this.integrityOK = false ;        this.frontIndex = 0 ;        this.backIndex = desiredCapacity - 1 ;        this.numberOfEntries = 0 ;        this.queue = null ;     // release the space for the current array (if                                // any)        checkCapacity( desiredCapacity ) ;        // The cast is safe because the new array contains null entries        @SuppressWarnings( "unchecked" )        final T[] tempQueue = (T[]) new Object[ desiredCapacity ] ;        this.queue = tempQueue ;        this.integrityOK = true ;        }   // end initializeState()    /**     * Determine if the queue's array is full     *     * @return true if the array is full, false otherwise     */    private boolean isArrayFull()        {        return this.numberOfEntries == this.queue.length ;        }   // end isArrayFull()    /*     * testing/debugging methods     */    // This method is not typically implemented - I included it for debugging    // purposes    @Override    public String toString()        {        return String.format( "frontIndex: %,2d; backIndex: %,2d; numberOfEntries: %,2d; integrityOK: %b; queue (length: %s): %s",                              this.frontIndex,                              this.backIndex,                              this.numberOfEntries,                              this.integrityOK,                              ( this.queue == null                                      ? "n/a"                                      : String.format( "%,d", this.queue.length ) ),                              Arrays.toString( this.queue ) ) ;        }   // end toString()    /**     * (optional) driver for testing/debugging     *     * @param args     *     -unused-     */    public static void main( final String[] args )        {        // for testing/debugging        // track values enqueue()d        int nextData = 1 ;        // create a queue        System.out.println( "empty queue" ) ;        final QueueInterface<Integer> testQueue = new ArrayQueue<>( 3 ) ;        final ArrayQueue<?> testArrayQueue = (ArrayQueue<?>) testQueue ;        // to access instance variables        System.out.println( testQueue.toString() ) ;        System.out.println() ;        // fill its array        // need to save the array length so we stop correctly with the book's        // implementation        final int arrayLength = testArrayQueue.queue.length ;        for ( int i = 0 ; i < arrayLength ; i++ )            {            System.out.printf( "enqueue(%,d)%n", nextData ) ;            testQueue.enqueue( nextData ) ;            nextData++ ;            System.out.println( testQueue.toString() ) ;            System.out.println() ;            }        // cause the array to be resized        System.out.printf( "enqueue(%,d)%n", nextData ) ;        testQueue.enqueue( nextData ) ;        nextData++ ;        System.out.println( testQueue.toString() ) ;        System.out.println() ;        // remove a couple of entries        System.out.printf( "dequeue() -> %,d%n", testQueue.dequeue() ) ;        System.out.println( testQueue.toString() ) ;        System.out.println() ;        System.out.printf( "dequeue() -> %,d%n", testQueue.dequeue() ) ;        System.out.println( testQueue.toString() ) ;        System.out.println() ;        // re-fill the array        final int numberOfEntriesToAdd = testArrayQueue.queue.length - testArrayQueue.numberOfEntries ;        for ( int i = 0 ; i < numberOfEntriesToAdd ; i++ )            {            System.out.printf( "enqueue(%,d)%n", nextData ) ;            testQueue.enqueue( nextData ) ;            nextData++ ;            System.out.println( testQueue.toString() ) ;            System.out.println() ;            }        // cause the array to be resized        System.out.printf( "enqueue(%,d)%n", nextData ) ;        testQueue.enqueue( nextData ) ;        nextData++ ;        System.out.println( testQueue.toString() ) ;        System.out.println() ;        // reset the queue        System.out.println( "clear()" ) ;        testQueue.clear() ;        System.out.println( testQueue.toString() ) ;        System.out.println() ;        // invalidate the structure        ( (ArrayQueue<Integer>) testQueue ).queue = null ;        ( (ArrayQueue<Integer>) testQueue ).integrityOK = false ;        System.out.printf( "%ninvalid structure:%n\t%s%n", testQueue ) ;        }   // end main()    } // end class ArrayQueue